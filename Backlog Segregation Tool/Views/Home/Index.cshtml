@model BacklogDataModel

<style>
	.tab {
		overflow: hidden;
		border: 1px solid #ccc;
		background-color: #f1f1f1;
	}

		/* Style the buttons that are used to open the tab content */
		.tab button {
			background-color: inherit;
			float: left;
			border: none;
			outline: none;
			cursor: pointer;
			padding: 14px 16px;
			transition: 0.3s;
		}

			/* Change background color of buttons on hover */
			.tab button:hover {
				background-color: #ddd;
			}

			/* Create an active/current tablink class */
			.tab button.active {
				background-color: #ccc;
			}

	/* Style the tab content */
	.tabcontent {
		display: none;
	}
</style>
<div>
	<table>
		<tr><td>Group Name:</td>
		<td>
			
	@Html.DropDownList("Group Name", new List<SelectListItem>
{
new SelectListItem{ Text="DCHA.3.Architect.AMS.Imp", Value = "DCHA.3.Architect.AMS.Imp",Selected=Model.IsImpSelected },
new SelectListItem{ Text="DCHA.3.Architect.AMS.Base", Value = "DCHA.3.Architect.AMS.Base",Selected=Model.IsBaseSelected }
}, new
{
	@onchange = "callChangefunc(this.value)"
}
)
</td>
		</tr>
	</table>
	
</div>

<div class="tab">
	<button class="tablinks active" onclick="openTab(event, 'Diplomets')">Diplomets</button>
	<button class="tablinks" onclick="openTab(event, 'Challangers')">Challangers</button>
	<button class="tablinks" onclick="openTab(event, 'Optimizers')">Optimizers</button>
	

</div>
<div id="Diplomets" style="display:block" class="tabcontent">
	UnAssigned Cases: @Model.DiplometsUnAssignedCases
	Assigned Cases: @Model.DiplometsAssignedCases
	Total Cases : @Model.backlog.Tables[0].Rows.Count
	<button class="btn btn-success" onclick="ExportToExcel('xlsx','diplomets');">Export</button>
	<table id="diplomets" class="table table-bordered table-responsive table-striped sortable">
		<thead class="table-dark">
			<TD>Pretriage Status</TD>
			@for (int ii = 0; ii < Model.backlog.Tables[0].Columns.Count - 1; ii++)
			{
<TD onclick="sortTable(@ii+1,'diplomets')">@Model.backlog.Tables[0].Columns[ii].ColumnName <icon></icon></TD>
		}
			</thead>

			@for (int i = 0; i < Model.backlog.Tables[0].Rows.Count; i++)
			{
				<tr>
					<td><input type="checkbox" value="" checked="@Model.backlog.Tables[0].Rows[i]["PreTriageStatus"]" disabled/></td>
					@for (int j = 0; j < Model.backlog.Tables[0].Columns.Count - 1; j++)
					{
						<td>@Model.backlog.Tables[0].Rows[i][j]</td>
					}
					
				</tr>


			}
		</table>
	</div>

<div id="Challangers" class="tabcontent">

	UnAssigned Cases: @Model.ChallangerUnAssignedCases
	Assigned Cases: @Model.ChallangerAssignedCases
	Total Cases : @Model.backlog.Tables[1].Rows.Count
	<button class="btn btn-success" onclick="ExportToExcel('xlsx','challangers');">Export</button>
	<table id="challangers" class="table table-bordered table-responsive table-striped sortable">
		<thead class="table-dark">
			<TD>Pretriage Status</TD>
			@for (int ii = 0; ii < Model.backlog.Tables[1].Columns.Count-1; ii++)
			{
			<TD onclick="sortTable(@ii+1,'challangers')">@Model.backlog.Tables[1].Columns[ii].ColumnName</TD>
		}
			</thead>
			@for (int i = 0; i < Model.backlog.Tables[1].Rows.Count; i++)
			{
	<tr>
		<td><input type="checkbox" value="" checked="@Model.backlog.Tables[1].Rows[i]["PreTriageStatus"]" disabled /></td>

		@for (int j = 0; j < Model.backlog.Tables[1].Columns.Count-1; j++)
		{
			<td>@Model.backlog.Tables[1].Rows[i][j]</td>
		}
	</tr>
			}
		</table>
	</div>

<div id="Optimizers" class="tabcontent">
	UnAssigned Cases: @Model.OptimizersUnAssignedCases
	Assigned Cases: @Model.OptimizersAssignedCases
	Total Cases : @Model.backlog.Tables[2].Rows.Count
	<button class="btn btn-success" onclick="ExportToExcel('xlsx','optimizers');">Export</button>
	<table id="optimizers" class="table table-bordered table-responsive table-striped sortable">
		<thead class="table-dark">
			<TD>Pretriage Status</TD>
			@for (int ii = 0; ii < Model.backlog.Tables[2].Columns.Count-1; ii++)
			{
<TD onclick="sortTable(@ii+1,'optimizers')">@Model.backlog.Tables[2].Columns[ii].ColumnName</TD>
		}
			</thead>
			@for (int i = 0; i < Model.backlog.Tables[2].Rows.Count; i++)
			{
	<tr>
		<td><input type="checkbox" value="" checked="@Model.backlog.Tables[2].Rows[i]["PreTriageStatus"]" disabled /></td>

		@for (int j = 0; j < Model.backlog.Tables[2].Columns.Count-1; j++)
		{
			<td>@Model.backlog.Tables[2].Rows[i][j]</td>
		}
	</tr>
			}
		</table>
	</div>

			<script>
	function openTab(evt, tableName) {
		// Declare all variables
		var i, tabcontent, tablinks;

		// Get all elements with class="tabcontent" and hide them
		tabcontent = document.getElementsByClassName("tabcontent");
		for (i = 0; i < tabcontent.length; i++) {
			tabcontent[i].style.display = "none";

		}

		// Get all elements with class="tablinks" and remove the class "active"
		tablinks = document.getElementsByClassName("tablinks");
		for (i = 0; i < tablinks.length; i++) {
			tablinks[i].className = tablinks[i].className.replace(" active", "");
		}

		// Show the current tab, and add an "active" class to the button that opened the tab
		document.getElementById(tableName).style.display = "block";
		evt.currentTarget.className += " active";
				}
				
	function sortTable(n,idname) {
		var table, rows, switching, i, x, y, shouldSwitch, dir, switchcount = 0;
		table = document.getElementById(idname);
		switching = true;
		// Set the sorting direction to ascending:
		dir = "asc";
		/* Make a loop that will continue until
		no switching has been done: */
		while (switching) {
			// Start by saying: no switching is done:
			switching = false;
			rows = table.rows;
			/* Loop through all table rows (except the
			first, which contains table headers): */
			for (i = 1; i < (rows.length - 1); i++) {
				// Start by saying there should be no switching:
				shouldSwitch = false;
				/* Get the two elements you want to compare,
				one from current row and one from the next: */
				x = rows[i].getElementsByTagName("TD")[n];
				y = rows[i + 1].getElementsByTagName("TD")[n];
				/* Check if the two rows should switch place,
				based on the direction, asc or desc: */
				if (dir == "asc") {
					if (x.innerHTML.toLowerCase() > y.innerHTML.toLowerCase()) {
						// If so, mark as a switch and break the loop:
						shouldSwitch = true;
						break;
					}
				} else if (dir == "desc") {
					if (x.innerHTML.toLowerCase() < y.innerHTML.toLowerCase()) {
						// If so, mark as a switch and break the loop:
						shouldSwitch = true;
						break;
					}
				}
			}
			if (shouldSwitch) {
				/* If a switch has been marked, make the switch
				and mark that a switch has been done: */
				rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
				switching = true;
				// Each time a switch is done, increase this count by 1:
				switchcount++;
			} else {
				/* If no switching has been done AND the direction is "asc",
				set the direction to "desc" and run the while loop again. */
				if (switchcount == 0 && dir == "asc") {
					dir = "desc";
					switching = true;
				}
			}
		}
				}

	function ExportToExcel(type, tablename, fn, dl) {
					var elt = document.getElementById(tablename);
					var wb = XLSX.utils.table_to_book(elt, { sheet: "sheet1" });
					return dl ?
						XLSX.write(wb, { bookType: type, bookSST: true, type: 'base64' }) :
						XLSX.writeFile(wb, fn || ('Backlog_'+tablename+'.' + (type || 'xlsx')));
				}

	function callChangefunc(val) {
		window.location.href = "/?gname=" + val;

				}
	
			</script>